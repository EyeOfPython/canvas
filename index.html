<html>

<head>
	<script type="text/javascript" src="http://code.jquery.com/jquery-2.1.3.min.js"></script>
	<script type="text/javascript" src="lib/codemirror.js"></script>
	<link rel="stylesheet" href="lib/codemirror.css" type="text/css">
	<script type="text/javascript" src="lib/xml/xml.js"></script>
	<script type="text/javascript" src="lib/javascript/javascript.js"></script>
	<script type="text/javascript" src="lib/css/css.js"></script>
	<script type="text/javascript" src="lib/htmlmixed/htmlmixed.js"></script>
	<script type="text/javascript" src="lib/glMatrix-0.9.5.min.js"></script>
	<script type="text/javascript" src="lib/webgl-utils.js"></script>

	<style type="text/css">
	button {
		border: 1px solid grey;
		border-radius: 4px;
		padding: 6px;
		margin: 5px;
	}
	</style>
</head>

<body>
<div style="font-size: 18px;">

<div style="float: left; width: 780px;">
	<textarea id="mainCanvas-text"></textarea>
	<button onclick="loadTemplate(1)">HTML Template</button>
	<button onclick="loadTemplate(2)">Canvas Template</button>
	<button onclick="loadTemplate(3)">Pacman Template</button>
	<button onclick="loadTemplate(4)">HPE Logo</button>
	<button onclick="loadTemplate(5)">Triforce Template</button>
	<button onclick="loadTemplate(6)">WebGL Hello Void</button>
	<button onclick="loadTemplate(7)">Super Epic WebGL Demo Cube Pyramid Stuff Don't Spoiler Pls</button>
</div>

<div id="mainCanvas-target" style="float: left; width: 480px;">
</div>

<script type="text/javascript">
	var mirr_mainCanvas = CodeMirror.fromTextArea( $('#mainCanvas-text')[0], {lineNumbers:true, mode:'htmlmixed', htmlMode:true} );
	mirr_mainCanvas.setSize(780, 600);

	mirr_mainCanvas.on('changes', function () {
		$("#mainCanvas-target").html(mirr_mainCanvas.getValue());
	});

	function loadTemplate(idx) {
		var txt;

		switch (idx) {
			case 1:
			txt = '<!DOCTYPE HTML>\n' +
'<html>\n' +
'  <head></head>\n' +
'  <body>\n' +
'    \n' +
'  </body>\n' +
'</html>';
			break;
			case 2:
			txt = '<!DOCTYPE HTML>\n' +
'<html>\n' +
'  <head></head>\n' +
'  <body>\n' +
'    <canvas id="myCanvas" width="578" height="200"></canvas>\n' +
'    <script>\n' +
'      var canvas = document.getElementById("myCanvas");\n' +
'      var context = canvas.getContext("2d");\n' +
'\n' +
'      // do cool things with the context\n' +
'    </'+'script>\n' +
'  </body>\n' +
'</html>';
break;
      case 3:
      txt = '<!DOCTYPE HTML>\n' + 
'<html>\n' + 
'  <body>\n' + 
'    <canvas id="myCanvas03" width="480" height="200"></canvas>\n' + 
'    <script>\n' + 
'      var canvas = document.getElementById("myCanvas03");\n' + 
'      var context = canvas.getContext("2d");\n' + 
'\n' + 
'      context.beginPath();\n' + 
'      context.moveTo(110, 55);\n' + 
'      context.lineTo(65, 75);\n' + 
'      context.lineTo(110, 95);\n' + 
'\n' + 
'      context.stroke();\n' + 
'\n' + 
'    </'+'script>\n' + 
'  </body>   \n' + 
'</html>';
      break;

      case 4:
      txt = '<!DOCTYPE HTML>\n' + 
'<html>\n' + 
'  <body>\n' + 
'    <canvas id="myCanvas08" width="480" height="200"></canvas>\n' + 
'    <script>\n' + 
'      var canvas = document.getElementById("myCanvas08");\n' + 
'      var context = canvas.getContext("2d");\n' + 
'\n' + 
'      context.strokeStyle = "#03af87";\n' + 
'      context.lineWidth=9;\n' + 
'      context.strokeRect(52, 27, 136, 35);\n' + 
'      context.font = "bold 46pt Calibri";\n' + 
'      context.fillText("Hewlett Packard", 44, 130);\n' + 
'      context.font = "46pt Calibri";\n' + 
'      context.fillText("Enterprise", 44, 182);\n' + 
'    </'+'script>\n' + 
'  </body>   \n' + 
'</html>';
      break;

      case 5:
      txt = '<!DOCTYPE HTML>\n' + 
'<html>\n' + 
'  <body>\n' + 
'    <canvas id="myCanvas06" width="480" height="200"></canvas>\n' + 
'    <script>\n' + 
'      var canvas = document.getElementById("myCanvas06");\n' + 
'      var context = canvas.getContext("2d");\n' + 
'\n' + 
'    <'+'/script>\n' + 
'  </body>   \n' + 
'</html>\n' + 
'';
      break;

      case 6:
      txt = '<!DOCTYPE HTML>\n' + 
'<html>\n' + 
'  <head>\n' + 
'    <script type="text/javascript">\n' + 
'    var gl;\n' + 
'    function initGL(canvas) {\n' + 
'        try {\n' + 
'            gl = canvas.getContext("experimental-webgl");\n' + 
'            gl.viewportWidth = canvas.width;\n' + 
'            gl.viewportHeight = canvas.height;\n' + 
'        } catch (e) {\n' + 
'        }\n' + 
'        if (!gl) {\n' + 
'            alert("Could not initialise WebGL, sorry :-(");\n' + 
'        }\n' + 
'    }\n' + 
'\n' + 
'    function drawScene() {\n' + 
'        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n' + 
'        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n' + 
'\n' + 
'    }\n' + 
'    function webGLStart() {\n' + 
'        var canvas = document.getElementById("myCanvas07");\n' + 
'        initGL(canvas);\n' + 
'\n' + 
'        gl.clearColor(0.0, 0.0, 0.0, 1.0);\n' + 
'\n' + 
'        drawScene();\n' + 
'    }\n' + 
'      \n' + 
'    $(webGLStart);\n' + 
'    </'+'script>\n' + 
'    \n' + 
'  </head>\n' + 
'  \n' + 
'  <body>\n' + 
'    <canvas id="myCanvas07" width="480" height="200"></canvas>\n' + 
'  </body>   \n' + 
'</html>';
			break;

			case 7:
			txt = '<html>\n' + 
'\n' + 
'<head>\n' + 
'<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">\n' + 
'\n' + 
'<script type="text/javascript" src="http://code.jquery.com/jquery-2.1.3.min.js"><'+'/script>\n' + 
'<script type="text/javascript" src="lib/glMatrix-0.9.5.min.js"><'+'/script>\n' + 
'<script type="text/javascript" src="lib/webgl-utils.js"><'+'/script>\n' + 
'\n' + 
'<script id="shader-fs" type="x-shader/x-fragment">\n' + 
'    precision mediump float;\n' + 
'\n' + 
'    varying vec4 vColor;\n' + 
'\n' + 
'    void main(void) {\n' + 
'        gl_FragColor = vColor;\n' + 
'    }\n' + 
'<'+'/script>\n' + 
'\n' + 
'<script id="shader-vs" type="x-shader/x-vertex">\n' + 
'    attribute vec3 aVertexPosition;\n' + 
'    attribute vec4 aVertexColor;\n' + 
'\n' + 
'    uniform mat4 uMVMatrix;\n' + 
'    uniform mat4 uPMatrix;\n' + 
'\n' + 
'    varying vec4 vColor;\n' + 
'\n' + 
'    void main(void) {\n' + 
'        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\n' + 
'        vColor = aVertexColor;\n' + 
'    }\n' + 
'<'+'/script>\n' + 
'\n' + 
'\n' + 
'<script type="text/javascript">\n' + 
'\n' + 
'    var gl;\n' + 
'\n' + 
'    function initGL(canvas) {\n' + 
'        try {\n' + 
'            gl = canvas.getContext("experimental-webgl");\n' + 
'            gl.viewportWidth = canvas.width;\n' + 
'            gl.viewportHeight = canvas.height;\n' + 
'        } catch (e) {\n' + 
'        }\n' + 
'        if (!gl) {\n' + 
'            alert("Could not initialise WebGL, sorry :-(");\n' + 
'        }\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    function getShader(gl, id) {\n' + 
'        var shaderScript = document.getElementById(id);\n' + 
'        if (!shaderScript) {\n' + 
'            return null;\n' + 
'        }\n' + 
'\n' + 
'        var str = "";\n' + 
'        var k = shaderScript.firstChild;\n' + 
'        while (k) {\n' + 
'            if (k.nodeType == 3) {\n' + 
'                str += k.textContent;\n' + 
'            }\n' + 
'            k = k.nextSibling;\n' + 
'        }\n' + 
'\n' + 
'        var shader;\n' + 
'        if (shaderScript.type == "x-shader/x-fragment") {\n' + 
'            shader = gl.createShader(gl.FRAGMENT_SHADER);\n' + 
'        } else if (shaderScript.type == "x-shader/x-vertex") {\n' + 
'            shader = gl.createShader(gl.VERTEX_SHADER);\n' + 
'        } else {\n' + 
'            return null;\n' + 
'        }\n' + 
'\n' + 
'        gl.shaderSource(shader, str);\n' + 
'        gl.compileShader(shader);\n' + 
'\n' + 
'        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n' + 
'            alert(gl.getShaderInfoLog(shader));\n' + 
'            return null;\n' + 
'        }\n' + 
'\n' + 
'        return shader;\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    var shaderProgram;\n' + 
'\n' + 
'    function initShaders() {\n' + 
'        var fragmentShader = getShader(gl, "shader-fs");\n' + 
'        var vertexShader = getShader(gl, "shader-vs");\n' + 
'\n' + 
'        shaderProgram = gl.createProgram();\n' + 
'        gl.attachShader(shaderProgram, vertexShader);\n' + 
'        gl.attachShader(shaderProgram, fragmentShader);\n' + 
'        gl.linkProgram(shaderProgram);\n' + 
'\n' + 
'        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n' + 
'            alert("Could not initialise shaders");\n' + 
'        }\n' + 
'\n' + 
'        gl.useProgram(shaderProgram);\n' + 
'\n' + 
'        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");\n' + 
'        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);\n' + 
'\n' + 
'        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");\n' + 
'        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);\n' + 
'\n' + 
'        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");\n' + 
'        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    var mvMatrix = mat4.create();\n' + 
'    var mvMatrixStack = [];\n' + 
'    var pMatrix = mat4.create();\n' + 
'\n' + 
'    function mvPushMatrix() {\n' + 
'        var copy = mat4.create();\n' + 
'        mat4.set(mvMatrix, copy);\n' + 
'        mvMatrixStack.push(copy);\n' + 
'    }\n' + 
'\n' + 
'    function mvPopMatrix() {\n' + 
'        if (mvMatrixStack.length == 0) {\n' + 
'            throw "Invalid popMatrix!";\n' + 
'        }\n' + 
'        mvMatrix = mvMatrixStack.pop();\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    function setMatrixUniforms() {\n' + 
'        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);\n' + 
'        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    function degToRad(degrees) {\n' + 
'        return degrees * Math.PI / 180;\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    var pyramidVertexPositionBuffer;\n' + 
'    var pyramidVertexColorBuffer;\n' + 
'    var cubeVertexPositionBuffer;\n' + 
'    var cubeVertexColorBuffer;\n' + 
'    var cubeVertexIndexBuffer;\n' + 
'\n' + 
'    function initBuffers() {\n' + 
'        pyramidVertexPositionBuffer = gl.createBuffer();\n' + 
'        gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);\n' + 
'        var vertices = [\n' + 
'            // Front face\n' + 
'             0.0,  1.0,  0.0,\n' + 
'            -1.0, -1.0,  1.0,\n' + 
'             1.0, -1.0,  1.0,\n' + 
'\n' + 
'            // Right face\n' + 
'             0.0,  1.0,  0.0,\n' + 
'             1.0, -1.0,  1.0,\n' + 
'             1.0, -1.0, -1.0,\n' + 
'\n' + 
'            // Back face\n' + 
'             0.0,  1.0,  0.0,\n' + 
'             1.0, -1.0, -1.0,\n' + 
'            -1.0, -1.0, -1.0,\n' + 
'\n' + 
'            // Left face\n' + 
'             0.0,  1.0,  0.0,\n' + 
'            -1.0, -1.0, -1.0,\n' + 
'            -1.0, -1.0,  1.0\n' + 
'        ];\n' + 
'        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n' + 
'        pyramidVertexPositionBuffer.itemSize = 3;\n' + 
'        pyramidVertexPositionBuffer.numItems = 12;\n' + 
'\n' + 
'        pyramidVertexColorBuffer = gl.createBuffer();\n' + 
'        gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);\n' + 
'        var colors = [\n' + 
'            // Front face\n' + 
'            1.0, 0.0, 0.0, 1.0,\n' + 
'            0.0, 1.0, 0.0, 1.0,\n' + 
'            0.0, 0.0, 1.0, 1.0,\n' + 
'\n' + 
'            // Right face\n' + 
'            1.0, 0.0, 0.0, 1.0,\n' + 
'            0.0, 0.0, 1.0, 1.0,\n' + 
'            0.0, 1.0, 0.0, 1.0,\n' + 
'\n' + 
'            // Back face\n' + 
'            1.0, 0.0, 0.0, 1.0,\n' + 
'            0.0, 1.0, 0.0, 1.0,\n' + 
'            0.0, 0.0, 1.0, 1.0,\n' + 
'\n' + 
'            // Left face\n' + 
'            1.0, 0.0, 0.0, 1.0,\n' + 
'            0.0, 0.0, 1.0, 1.0,\n' + 
'            0.0, 1.0, 0.0, 1.0\n' + 
'        ];\n' + 
'        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\n' + 
'        pyramidVertexColorBuffer.itemSize = 4;\n' + 
'        pyramidVertexColorBuffer.numItems = 12;\n' + 
'\n' + 
'\n' + 
'        cubeVertexPositionBuffer = gl.createBuffer();\n' + 
'        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);\n' + 
'        vertices = [\n' + 
'            // Front face\n' + 
'            -1.0, -1.0,  1.0,\n' + 
'             1.0, -1.0,  1.0,\n' + 
'             1.0,  1.0,  1.0,\n' + 
'            -1.0,  1.0,  1.0,\n' + 
'\n' + 
'            // Back face\n' + 
'            -1.0, -1.0, -1.0,\n' + 
'            -1.0,  1.0, -1.0,\n' + 
'             1.0,  1.0, -1.0,\n' + 
'             1.0, -1.0, -1.0,\n' + 
'\n' + 
'            // Top face\n' + 
'            -1.0,  1.0, -1.0,\n' + 
'            -1.0,  1.0,  1.0,\n' + 
'             1.0,  1.0,  1.0,\n' + 
'             1.0,  1.0, -1.0,\n' + 
'\n' + 
'            // Bottom face\n' + 
'            -1.0, -1.0, -1.0,\n' + 
'             1.0, -1.0, -1.0,\n' + 
'             1.0, -1.0,  1.0,\n' + 
'            -1.0, -1.0,  1.0,\n' + 
'\n' + 
'            // Right face\n' + 
'             1.0, -1.0, -1.0,\n' + 
'             1.0,  1.0, -1.0,\n' + 
'             1.0,  1.0,  1.0,\n' + 
'             1.0, -1.0,  1.0,\n' + 
'\n' + 
'            // Left face\n' + 
'            -1.0, -1.0, -1.0,\n' + 
'            -1.0, -1.0,  1.0,\n' + 
'            -1.0,  1.0,  1.0,\n' + 
'            -1.0,  1.0, -1.0\n' + 
'        ];\n' + 
'        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n' + 
'        cubeVertexPositionBuffer.itemSize = 3;\n' + 
'        cubeVertexPositionBuffer.numItems = 24;\n' + 
'\n' + 
'        cubeVertexColorBuffer = gl.createBuffer();\n' + 
'        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);\n' + 
'        colors = [\n' + 
'            [1.0, 0.0, 0.0, 1.0], // Front face\n' + 
'            [1.0, 1.0, 0.0, 1.0], // Back face\n' + 
'            [0.0, 1.0, 0.0, 1.0], // Top face\n' + 
'            [1.0, 0.5, 0.5, 1.0], // Bottom face\n' + 
'            [1.0, 0.0, 1.0, 1.0], // Right face\n' + 
'            [0.0, 0.0, 1.0, 1.0]  // Left face\n' + 
'        ];\n' + 
'        var unpackedColors = [];\n' + 
'        for (var i in colors) {\n' + 
'            var color = colors[i];\n' + 
'            for (var j=0; j < 4; j++) {\n' + 
'                unpackedColors = unpackedColors.concat(color);\n' + 
'            }\n' + 
'        }\n' + 
'        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);\n' + 
'        cubeVertexColorBuffer.itemSize = 4;\n' + 
'        cubeVertexColorBuffer.numItems = 24;\n' + 
'\n' + 
'        cubeVertexIndexBuffer = gl.createBuffer();\n' + 
'        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);\n' + 
'        var cubeVertexIndices = [\n' + 
'            0, 1, 2,      0, 2, 3,    // Front face\n' + 
'            4, 5, 6,      4, 6, 7,    // Back face\n' + 
'            8, 9, 10,     8, 10, 11,  // Top face\n' + 
'            12, 13, 14,   12, 14, 15, // Bottom face\n' + 
'            16, 17, 18,   16, 18, 19, // Right face\n' + 
'            20, 21, 22,   20, 22, 23  // Left face\n' + 
'        ];\n' + 
'        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);\n' + 
'        cubeVertexIndexBuffer.itemSize = 1;\n' + 
'        cubeVertexIndexBuffer.numItems = 36;\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    var rPyramid = 0;\n' + 
'    var rCube = 0;\n' + 
'\n' + 
'    function drawScene() {\n' + 
'        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);\n' + 
'        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n' + 
'\n' + 
'        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);\n' + 
'\n' + 
'        mat4.identity(mvMatrix);\n' + 
'\n' + 
'        mat4.translate(mvMatrix, [-1.5, 0.0, -8.0]);\n' + 
'\n' + 
'        mvPushMatrix();\n' + 
'        mat4.rotate(mvMatrix, degToRad(rPyramid), [0, 1, 0]);\n' + 
'\n' + 
'        gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);\n' + 
'        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, pyramidVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n' + 
'\n' + 
'        gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);\n' + 
'        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, pyramidVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);\n' + 
'\n' + 
'        setMatrixUniforms();\n' + 
'        gl.drawArrays(gl.TRIANGLES, 0, pyramidVertexPositionBuffer.numItems);\n' + 
'\n' + 
'        mvPopMatrix();\n' + 
'\n' + 
'\n' + 
'        mat4.translate(mvMatrix, [3.0, 0.0, 0.0]);\n' + 
'\n' + 
'        mvPushMatrix();\n' + 
'        mat4.rotate(mvMatrix, degToRad(rCube), [1, 1, 1]);\n' + 
'\n' + 
'        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);\n' + 
'        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);\n' + 
'\n' + 
'        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);\n' + 
'        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);\n' + 
'\n' + 
'        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);\n' + 
'        setMatrixUniforms();\n' + 
'        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);\n' + 
'\n' + 
'        mvPopMatrix();\n' + 
'\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    var lastTime = 0;\n' + 
'\n' + 
'    function animate() {\n' + 
'        var timeNow = new Date().getTime();\n' + 
'        if (lastTime != 0) {\n' + 
'            var elapsed = timeNow - lastTime;\n' + 
'\n' + 
'            rPyramid += (90 * elapsed) / 1000.0;\n' + 
'            rCube -= (75 * elapsed) / 1000.0;\n' + 
'        }\n' + 
'        lastTime = timeNow;\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    function tick() {\n' + 
'        requestAnimFrame(tick);\n' + 
'        drawScene();\n' + 
'        animate();\n' + 
'    }\n' + 
'\n' + 
'\n' + 
'    function webGLStart() {\n' + 
'        var canvas = document.getElementById("myCanvas08");\n' + 
'        initGL(canvas);\n' + 
'        initShaders()\n' + 
'        initBuffers();\n' + 
'\n' + 
'        gl.clearColor(0.0, 0.0, 0.0, 1.0);\n' + 
'        gl.enable(gl.DEPTH_TEST);\n' + 
'\n' + 
'        tick();\n' + 
'    }\n' + 
'\n' + 
'    $(webGLStart);\n' + 
'</'+'script>\n' + 
'\n' + 
'\n' + 
'</head>\n' + 
'\n' + 
'\n' + 
'<body>\n' + 
'    <canvas id="myCanvas08" width="500" height="500"></canvas>\n' + 
'</body>\n' + 
'\n' + 
'</html>\n' + 
'';
			break;
			default:
		}

		mirr_mainCanvas.setValue(txt);
	}
</script>

</div>
</body>

</html>